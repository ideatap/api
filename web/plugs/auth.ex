defmodule Ideatap.Plugs.Auth do
  @moduledoc """
  This Plug is responsible for authenticating a user that tries to access API
  endpoints. When a user signs-in or creates an account, they are assigned a token
  generated by `Phoenix.Token.sign/3`.

  The goal is to allow other controllers/plugs access to the user making the request
  and in this case, it would be the EmberJS application.

  TODO: Implement other options for tokens, such as Joken and JWT stuff.
  """

  import Plug.Conn
  import Ecto.Query, only: [from: 2]
  alias Ideatap.{Repo, User}

  def init(opts), do: opts

  @doc """
  Checks whether a token is known. If a user is found with the given token, assign
  that user to :authenticated_user in the connection so other plugs and controller
  actions have access to that user.

  If there is either no token, or an unknown user from that token, send a
  401 response and halt the connection pipeline.
  """
  def call(conn, _params) do
    case check_token(conn, get_token(conn)) do
      {:ok, user} -> assign(conn, :authenticated_user, user)
      {:error, message} -> send_resp(conn, 401, "Not Authorized") |> halt()
      nil -> send_resp(conn, 500, "Unknown Error") |> halt()
    end
  end

  @doc """
  Checks whether the token passed is assigned to a user and the id is correct.

  `Phoenix.Token.verify/3` is necessary to get the user id from the signed token.
  """
  def check_token(conn, %{error: message}), do: {:error, "Not Authorized"}
  def check_token(conn, %{token: token}) do
    case validates_token(conn, token) do
      {:ok, token, data} -> check_token_is_known(token, data)
      {:error, message} -> {:error, message}
    end
  end

  @doc """
  Finds a single user in the database given a `token` and the tokens' `data`, which
  in this case would be the users id.
  """
  def check_token_is_known(token, data) do
    query = from u in User, where: u.id == ^data and
      fragment("? @> ?", u.authentication_tokens, ^[token])

    case Repo.one(query) do
      nil -> {:error, :unknown_token}
      user -> {:ok, user}
    end
  end

  @doc """
  Just a helper function to return the Token data and original token.
  """
  def validates_token(conn, token) do
    case Phoenix.Token.verify(conn, "user", token) do
      {:ok, data} -> {:ok, token, data}
      {:error, _} -> {:error, "Not Valid"}
    end
  end

  @doc """
  Fetches the `Authorization` header from the request and gets the token.
  """
  def get_token(conn) do
    get_req_header(conn, "authorization") |> token_from_header()
  end

  @doc """
  Checks if there is a `Bearer <token>` in the authorization header.
  """
  def token_from_header(["Bearer " <> token]), do: %{token: token}
  def token_from_header(_), do: %{error: "Not Present"}
end
